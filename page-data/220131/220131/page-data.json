{"componentChunkName":"component---src-templates-post-template-tsx","path":"/220131/220131/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>useEffect</h1>\n<p>useEffect를 활용하여 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리할 수 있습니다.</p>\n<ul>\n<li>클래스 컴포넌트의 life cycle 함수를 함수 컴포넌트에도 동일하게 사용 가능합니다.</li>\n<li>최초 컴포넌트 마운트 되는 경우, 컴포넌트 내 레이아웃 배치와 랜더링이 완료된 후에 실행됩니다.</li>\n<li>두 번째 인자(배열)의 요소로 지정하면, 해당 요소 값의 업데이트 되는 경우에만 실행됩니다.</li>\n<li>state나 props를 dependency로 지정하면, 불필요한 랜더링 발생 가능할 수 있으니 주의해야 합니다.</li>\n</ul>\n<p>외부 데이터에 구독(subscription)을 설정해야 하는 경우를 생각해보겠습니다. 이런 경우에 메모리 누수가 발생하지 않도록 정리(clean-up)하는 것은 매우 중요합니다.</p>\n<h3>관심사를 구분하려고 한다면 Multiple Effect를 사용합니다</h3>\n<p>Hook이 탄생한 동기가 된 문제 중의 하나가 생명주기 class 메서드가 관련이 없는 로직들은 모아놓고, 관련이 있는 로직들은 여러 개의 메서드에 나누어 놓는 문제를 해결하기 위함입니다.</p>\n<h4>Mount or Update</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() => console.log('will update any'));</code></pre></div>\n<h4>Unmount or Update</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() => () => console.log('will update any or unmount'));</code></pre></div>\n<h4>Update Count</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() => console.log('will update count'), [count]);</code></pre></div>\n<h4>#### Update Count or Unmount</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">useEffect(() => () => console.log('will update count or unmount'), [count]);</code></pre></div>\n<h1>useMemo</h1>\n<ul>\n<li>메모이제이션 된 값을 반환합니다</li>\n<li>의존성이 변경되는 경우, 이전에 기억하고 있던 리턴 값과 비교해서 다른 경우에만 리랜더 합니다.</li>\n<li>useMemo에서 전달된 함수는 랜더링 중에 실행되므로, 랜더링 중에서 실행하지 않는 함수는 useEffect를 사용할 것 합니다.</li>\n<li>useRef와의 차이는, useRef는 DOM element의 특정 속성 값을 기억한다면, useMemo는 특정 함수의 리턴 값을</li>\n</ul>\n<h1>useCallback</h1>\n<ul>\n<li>메모이제이션 된 콜백(함수) 자체를 반환합니다.</li>\n<li>useCallback(fn, deps)은 useMemo(() => fn, deps)과 동일합니다.</li>\n<li>의존성이 변경되는 경우, 이전에 기억하고 있던 함수 자체와 비교해서 다른 경우에만 리랜더 합니다.</li>\n</ul>\n<br/>\n<h4>참고자료</h4>\n<blockquote>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-effect.html\" target=\"_blank\" rel=\"nofollow\">리액트: Using the Effect Hook</a> > <a href=\"https://react.vlpt.us/basic/16-useEffect.html\" target=\"_blank\" rel=\"nofollow\">벨로퍼트와 함께하는 모던 리액트</a></p>\n</blockquote>","frontmatter":{"title":"[리액트 공부하기] #4 useMemo, useEffect,useCallback의 사용","summary":"#4 리액트 공식문서를 참고하며 개인적으로 공부한 내용을 정리한 내용입니다.","date":"2022.01.31.","categories":["프론트엔드","리액트","TIL"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlElEQVQoz2Ooq2/+T03MgEuitq4JL58kA2GaQXRNbSNRFuI0ENmwhsbW/80tHf+raxr+V1XXg2mQBchqiPYySPPiJcv+b9m6/f/UaTP/z5gx539f/6T//ROm/K9vaCHehcgGzpg55//KlWv+d3b1/Z84aer/vv7J/7u6+8n3ck0tJAwp9jIxMUqyl6mabGiSsMk1EADnbSgu+xka5AAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/79ad154ded65cc0bff2ec9548d002a2e/e018d/thumbnail.png","srcSet":"/static/79ad154ded65cc0bff2ec9548d002a2e/c6b60/thumbnail.png 480w,\n/static/79ad154ded65cc0bff2ec9548d002a2e/f5e84/thumbnail.png 960w,\n/static/79ad154ded65cc0bff2ec9548d002a2e/e018d/thumbnail.png 1920w","sizes":"(min-width: 1920px) 1920px, 100vw"},"sources":[{"srcSet":"/static/79ad154ded65cc0bff2ec9548d002a2e/0df1a/thumbnail.webp 480w,\n/static/79ad154ded65cc0bff2ec9548d002a2e/eeb31/thumbnail.webp 960w,\n/static/79ad154ded65cc0bff2ec9548d002a2e/702da/thumbnail.webp 1920w","type":"image/webp","sizes":"(min-width: 1920px) 1920px, 100vw"}]},"width":1920,"height":1080}},"publicURL":"/static/79ad154ded65cc0bff2ec9548d002a2e/thumbnail.png"}}}}]}},"pageContext":{"slug":"/220131/220131/"}},"staticQueryHashes":[]}