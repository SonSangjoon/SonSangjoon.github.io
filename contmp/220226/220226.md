---
date: '2022-02-26'
title: '[프로젝트 회고] React Query를 활용한 비동기 API 구현'
categories: ['프론트엔드', 'React Query', '리액트 쿼리', '싸페']
summary: '프로젝트에서 고민했던 흔적을 정리해둔 게시물입니다.'
thumbnail: './thumbnail.png'
---

# React Query를 활용한 비동기 API 구현

React Query는 React 앱에서 비동기 로직을 쉽게 다루도록 해주는 라이브러리입니다. 현재 대부분의 웹 어플리케이션은 비동기로직을 사용한다고 볼 수 있습니다. 유저에게 제공되는 데이터의 양과 질을 높일 수 있는 가장 기본적인 방식이기 때문입니다.

React Query에 대한 기본적이 내용은 저의 [블로그 글](https://sonsangjoon.github.io/220306/220306/)에 정리해두었습니다. 아래의 내용은 프로젝트에 React Query를 사용하여 구현한 내용과 추가적인 Action 플랜을 정리해봤습니다.

- Infinite Queries를 활용한 무한 스크롤링 구현
- Suspense와 React Query를 통한 비동기 API
- 추가적인 보완사항

# 1. Infinite Queries를 활용한 무한 스크롤링 구현

### Infinite Queries

무한 쿼리는 기존 데이터 집합에 추가로 "더 많은" 데이터를 로드하거나 무한 스크롤할 수 있는 렌더링 목록도 매우 일반적인 UI 패턴입니다. React Query는 Infinite Queries를 통해 더욱 효율적으로 useQuery를 사용할 수 있도록 합니다.

```javascript
const {
  data, // infinite query data를 담고 있는 객체입니다.
  error,
  fetchNextPage, // 데이터를 추가적으로 호출할 수 있도록 하는 함수입니다.
  hasNextPage, //더 호출할 데이터가 있는지 boolean 형태로 반환합니다. getNextPageParam가 undefined가 아닌 이상 true를 반환합니다.
  isFetching,
  isFetchingNextPage,
  status,
} = useInfiniteQuery('projects', fetchProjects, {
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
})
```

### 구현 방식

커뮤니티, 채용, 스터디 목록 모두 Infinite Queries를 사용하여 구현했습니다. 아래 예시는 커뮤니티 게시글 목록을 무한 스크롤로 구현한 내용입니다.

검색 쿼리에 대한 정보와 page에 대한 정보를 params에 담아서 보냅니다.
다만 nextPage에 대한 정보를 다시 반환했습니다.

다른 예시들을 참고했을 때, 서버에서 다음 페이지에 대한 정보를 함께 보내주는 경우도 있었습니다.
동시에 마지막 페이지일 경우에는 false를 전달해주기 위함이었습니다.

저의 경우에는, 서버쪽에서 보내주지 않아 제가 직접 다음페이지에 대한 정보를 생성해주었습니다.
또한, 마지막 페이지인지 확인하는 과정도 프론트에서 진행했습니다. 관련 내용은 바로 하단에 정리했습니다.

```javascript
// getCommunityList.js
const fetchPage = async (data, pageParam) => {
  const param = {
    ...data,
    offset: pageParam,
  }
  const res = await axiosInstance({
    url: `/boards/search/`,
    params: param,
  })
  return { res: res.data, nextPage: pageParam + 1 }
}
```

getNextPageParam을 통해 다음 페이지에 대한 pageParam을 생성할 수 있습니다.
제가 설정한 nextPage는 prevPage.nextPage를 통해서 가져올 수 있습니다.
다만 마지막 페이지에 대한 정보는 prevPage.res.length를 통해 확인해 주었습니다.

이때, 추가적으로 호출할 데이터가 없는 경우에는, undefined를 반환해야지 getNextPageParam이 false로 반환되니 확인이 필요합니다.

```javascript
// getCommunityList.js
export const GetCommunityList = data =>
  useInfiniteQuery(
    ['getCommunityList', data],
    ({ pageParam = 1 }) => fetchPage(data, pageParam),
    {
      getNextPageParam: prevPage => {
        return !!prevPage.res.length ? prevPage.nextPage : undefined
      },
    },
  )
```

이제 커뮤니티 게시글을 페이지 단위로 정보를 불러오기 위한 기초 쿼리는 완성이 되었습니다.
무한 스크롤의 경우, 기본적으로 2가지 방식을 통해 구현해볼 수 있습니다.

- scroll event listener: 스크롤에 대한 조건을 만족했을 경우, 추가 데이터를 가져오는 방식
- Intersection Observer API: 타깃으로 삼은 엘리먼트를 관찰해, 특정조건이 되면 데이터를 가져오는 방식

저의 경우 Intersection Observer을 사용했습니다.
MDN에 따르면, Intersection Observer API는 타겟 요소와 상위 요소 또는 최상위 document 의 viewport 사이의 intersection 내의 변화를 비동기적으로 관찰하는 API입니다. Event listener를 등록하는 방식과 다르게, dobounce나 throttle을 적용시켜주지 않아도 되며, Reflow가 발생하지 않기 때문입니다.

이에 useIntersectionObserver라는 hook을 만들어 필요한 곳에 사용할 수 있도록 했습니다.

- target: useIntersectionObserver의 객체입니다.
- onIntersect: target 엘레멘트와 교차했을 때 호출할 함수를 정의합니다.
- enabled: useIntersectionObserver의 실행 여부를 설정합니다.

```javascript
// useIntersectionObserver.js
import { useEffect } from 'react'

export const useIntersectionObserver = ({ target, onIntersect, enabled }) => {
  useEffect(() => {
    const el = target?.current

    if (!enabled || !el) {
      return
    }

    const observer = new IntersectionObserver(
      entries =>
        entries.forEach(entry => entry.isIntersecting && onIntersect()),
      {
        threshold: 1.0,
      },
    )

    observer.observe(el)
    return () => {
      observer.unobserve(el)
    }
  }, [target, enabled, onIntersect])
}
```

useIntersectionObserver 게시물의 가장 하단에 추가적인 로드를 위한 컴포넌트를 넣어두었습니다.

이후 Infinite Queries와 useIntersectionObserver와 연결해주었습니다.

- target: 게시물의 가장 하단의 컴포넌트로 설정했습니다.
- onIntersect: 교차할 경우, fetchNextPage로 추가적인 데이터를 호출하도록 했습니다.
- enabled: hasNextPage을 통해 추가적인 데이터 여부를 판단하여, 없을 경우 추가적인 호출을 제한했습니다.

```javascript
const CommunityFeedGrid = () => {
  .
  .
  .
  const loader = useRef(null)
  const { data, fetchNextPage, hasNextPage } = GetCommunityList({`검색 쿼리에 대한 정보`})
  const { feedData } = CommunityFeedSelector(data)

  const onFetchNewData = () => {
    fetchNextPage()
  }

  useIntersectionObserver({
    target: loader,
    onIntersect: onFetchNewData,
    enabled: hasNextPage,
  })

  return (
    <>
      {!feedData[0] && <CommunityNoContent theme={theme} />}
      <FeedGrid data={feedData} theme={theme} />
      <FetchBox ref={loader} />
    </>
  )
}

export default CommunityFeedGrid
```

# 2 Suspense와 React Query를 통한 비동기 API

### React Query와 Suspense

React Query는 React Suspense를 지원합니다.
Suspense를 사용하기 위해 전역을 설정하거나 각 쿼리별로 react suspense의 사용여부를 설정할 수 있습니다.

```javascript
//전역으로 설절
import { QueryClient, QueryClientProvider } from 'react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      suspense: true,
    },
  },
})

function Root() {
  return (
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  )
}

//개별 쿼리에 대해서 설정
import { useQuery } from 'react-query'

useQuery(queryKey, queryFn, { suspense: true })
```

### 구현 방식

# 3 추가적인 보완 사항

### Query Cancellation

### Optimistic Updates

# 4. 끝맺음

참고:
[React 무한 스크롤 구현하기 with Intersection Observer](https://velog.io/@jce1407/React-%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-with-Intersection-Observer)
